<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hold Window Prototype - Chain 2: Cheese Sauce</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      padding: 20px;
      background: #0a0a0a;
      color: #e0e0e0;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    h1 {
      font-size: 24px;
      margin-bottom: 8px;
      background: linear-gradient(90deg, #00d4ff, #7b2ff7);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      font-weight: bold;
    }

    .subtitle {
      color: #888;
      margin-bottom: 24px;
      font-size: 14px;
    }

    .controls {
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 24px;
    }

    .control-group {
      display: flex;
      gap: 16px;
      align-items: center;
      flex-wrap: wrap;
    }

    label {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: #aaa;
    }

    input[type="number"] {
      background: #0a0a0a;
      border: 1px solid #444;
      color: #e0e0e0;
      padding: 6px 10px;
      border-radius: 4px;
      width: 80px;
      font-size: 13px;
    }

    button {
      background: linear-gradient(135deg, #00d4ff, #7b2ff7);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
    }

    button:hover {
      opacity: 0.9;
    }

    .timeline {
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 24px;
      margin-bottom: 16px;
    }

    .timeline-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .timeline-title {
      font-size: 18px;
      font-weight: 600;
      color: #00d4ff;
    }

    .timeline-info {
      font-size: 12px;
      color: #888;
    }

    .time-axis {
      height: 30px;
      border-bottom: 1px solid #333;
      position: relative;
      margin-bottom: 16px;
    }

    .time-marker {
      position: absolute;
      bottom: 0;
      transform: translateX(-50%);
      font-size: 11px;
      color: #666;
    }

    .time-marker::before {
      content: '';
      position: absolute;
      bottom: -1px;
      left: 50%;
      transform: translateX(-50%);
      width: 1px;
      height: 6px;
      background: #444;
    }

    .task-track {
      height: 60px;
      position: relative;
      margin-bottom: 8px;
      border-bottom: 1px solid #222;
    }

    .task-label {
      position: absolute;
      left: 0;
      top: 8px;
      font-size: 12px;
      color: #aaa;
      width: 200px;
    }

    .task-bar-container {
      position: absolute;
      left: 220px;
      right: 0;
      height: 44px;
      top: 8px;
    }

    .task-bar {
      position: absolute;
      height: 100%;
      border-radius: 4px;
      display: flex;
      align-items: center;
      padding: 0 10px;
      font-size: 11px;
      font-weight: 600;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }

    /* Task bar solid section */
    .task-bar-solid {
      position: absolute;
      height: 100%;
      left: 0;
      border-radius: 4px 0 0 4px;
      background: linear-gradient(135deg, #00d4ff, #0099cc);
    }

    /* Hold window extension */
    .task-bar-extension {
      position: absolute;
      height: 100%;
      border-radius: 0 4px 4px 0;
      background: repeating-linear-gradient(
        45deg,
        rgba(0, 212, 255, 0.15),
        rgba(0, 212, 255, 0.15) 4px,
        rgba(0, 212, 255, 0.05) 4px,
        rgba(0, 212, 255, 0.05) 8px
      );
      border: 1px dashed rgba(0, 212, 255, 0.3);
      border-left: none;
    }

    .task-duration {
      position: absolute;
      z-index: 10;
      color: white;
      font-weight: 600;
      left: 10px;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }

    .hold-window-label {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 10px;
      color: rgba(0, 212, 255, 0.7);
      font-style: italic;
      z-index: 10;
    }

    .legend {
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 16px;
      display: flex;
      gap: 24px;
      font-size: 12px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .legend-box {
      width: 40px;
      height: 20px;
      border-radius: 3px;
    }

    .legend-solid {
      background: linear-gradient(135deg, #00d4ff, #0099cc);
    }

    .legend-extension {
      background: repeating-linear-gradient(
        45deg,
        rgba(0, 212, 255, 0.15),
        rgba(0, 212, 255, 0.15) 4px,
        rgba(0, 212, 255, 0.05) 4px,
        rgba(0, 212, 255, 0.05) 8px
      );
      border: 1px dashed rgba(0, 212, 255, 0.3);
    }

    .stats {
      margin-top: 16px;
      padding: 16px;
      background: #0a0a0a;
      border: 1px solid #333;
      border-radius: 8px;
      font-size: 13px;
      color: #aaa;
      line-height: 1.8;
    }

    .stats strong {
      color: #00d4ff;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Hold Window Visualization Prototype</h1>
    <p class="subtitle">Chain 2: Make the Cheese Sauce — Testing "Leave Time" Channel Extensions</p>

    <div class="controls">
      <div class="control-group">
        <label>
          Pixels per minute:
          <input type="number" id="pixelsPerMin" value="12" min="1" max="30">
        </label>
        <button onclick="render()">Re-render</button>
        <button onclick="loadMacAndCheese()">Load Mac & Cheese Data</button>
      </div>
    </div>

    <div class="timeline" id="timeline">
      <div class="timeline-header">
        <div class="timeline-title">Chain 2: Make the Cheese Sauce</div>
        <div class="timeline-info" id="timelineInfo">Loading...</div>
      </div>
      <div class="time-axis" id="timeAxis"></div>
      <div id="tracks"></div>
    </div>

    <div class="legend">
      <div class="legend-item">
        <div class="legend-box legend-solid"></div>
        <span>Task Duration (active work)</span>
      </div>
      <div class="legend-item">
        <div class="legend-box legend-extension"></div>
        <span>Hold Window (output stays viable)</span>
      </div>
    </div>

    <div class="stats" id="stats">
      Click "Load Mac & Cheese Data" to begin
    </div>
  </div>

  <script type="module">
    import { parseRecipe } from '../src/parser/index.js';

    // Sample chain data (will be replaced with actual parsed data)
    let chainData = null;

    window.loadMacAndCheese = async function() {
      const macCheeseNarrative = `Ingredients
Kosher salt
1 pound elbow macaroni
4 cloves garlic, smashed and divided
5 1/2 cups shredded sharp white Cheddar
2 tablespoons butter
3 tablespoons all-purpose flour
1 tablespoon powdered mustard
3 cups milk
1/2 medium onion, peeled and chopped
1 bay leaf
1/2 teaspoon paprika
1 teaspoon freshly ground black pepper
8 slices bacon, diced
1 large onion, diced
Thyme sprigs

Directions
Bring a pot of salted water to a boil over high heat. Add the macaroni and cook for 8 to 9 minutes, until al dente. Drain.

Preheat the oven to 400 degrees F.

In a small saucepan heat the milk with the thyme sprigs and 2 garlic cloves. Melt the butter in a large, deep skillet over medium-high heat. Whisk in the flour and cook for about 1 minute, stirring constantly, to keep lumps from forming. Still whisking, add the hot milk, bring up to a bubble, then add the cheese a little at a time. Keep whisking until the sauce is smooth. Add the mustard, paprika, black pepper. Fold the macaroni into the cheese sauce and keep stirring until well combined. Season with salt. Scrape into a buttered 3-quart casserole dish or into individual buttered gratin dishes.

Bake for 25 to 30 minutes, or until bubbly and the top is browned.

While that bakes, heat a saute pan. Add the bacon, render the fat and cook until crispy. Toss in the remaining garlic and the onion. Saute until soft and golden. Season with salt and pepper.

To serve, crumble the bacon mixture over the top of the mac and cheese. If desired, broil for 1 minute to really brown the top.`;

      console.log('🍝 Parsing Mac & Cheese...');

      const result = await parseRecipe(macCheeseNarrative, 'Mac & Cheese', {
        autoDependencies: false,
        detectTaskChains: true,
        useSemanticChains: true
      });

      console.log('✅ Parse complete:', result);

      // Find Chain 2 (Make the Cheese Sauce)
      const chain2 = result.chains?.find(c => c.name.includes('Cheese Sauce') || c.name.includes('cheese sauce'));

      if (chain2) {
        // Get the actual task objects for this chain
        const chain2Tasks = chain2.tasks.map(taskId => {
          return result.tasks.find(t => t.id === taskId);
        }).filter(Boolean);

        chainData = {
          name: chain2.name,
          tasks: chain2Tasks
        };

        console.log('✅ Found Chain 2:', chainData);
        render();
      } else {
        document.getElementById('stats').innerHTML = `
          <strong>Error:</strong> Could not find "Cheese Sauce" chain in parsed result.<br>
          Available chains: ${result.chains?.map(c => c.name).join(', ') || 'none'}
        `;
      }
    };

    window.render = function() {
      if (!chainData) {
        document.getElementById('stats').innerHTML = 'No data loaded. Click "Load Mac & Cheese Data" first.';
        return;
      }

      const pixelsPerMin = parseInt(document.getElementById('pixelsPerMin').value) || 12;

      // Calculate timeline dimensions
      let totalDuration = 0;
      chainData.tasks.forEach(task => {
        totalDuration += (task.planned_min || 0);
      });

      const maxHoldWindow = Math.max(...chainData.tasks.map(t => t.hold_window_minutes || 0));
      const timelineWidth = (totalDuration + maxHoldWindow) * pixelsPerMin;

      // Render time axis
      const timeAxis = document.getElementById('timeAxis');
      timeAxis.innerHTML = '';
      timeAxis.style.width = timelineWidth + 'px';

      const markerInterval = 5; // Every 5 minutes
      for (let t = 0; t <= totalDuration + maxHoldWindow; t += markerInterval) {
        const marker = document.createElement('div');
        marker.className = 'time-marker';
        marker.style.left = (t * pixelsPerMin) + 'px';
        marker.textContent = t + 'm';
        timeAxis.appendChild(marker);
      }

      // Render task tracks
      const tracks = document.getElementById('tracks');
      tracks.innerHTML = '';

      let currentStart = 0;
      chainData.tasks.forEach((task, idx) => {
        const duration = task.planned_min || 0;
        const holdWindow = task.hold_window_minutes || 0;
        const flexibility = task.temporal_flexibility || 'unknown';

        const track = document.createElement('div');
        track.className = 'task-track';

        const label = document.createElement('div');
        label.className = 'task-label';
        label.textContent = `${idx + 1}. ${task.name}`;
        track.appendChild(label);

        const barContainer = document.createElement('div');
        barContainer.className = 'task-bar-container';
        barContainer.style.width = timelineWidth + 'px';

        // Solid task bar
        const solidBar = document.createElement('div');
        solidBar.className = 'task-bar-solid';
        solidBar.style.left = (currentStart * pixelsPerMin) + 'px';
        solidBar.style.width = (duration * pixelsPerMin) + 'px';
        barContainer.appendChild(solidBar);

        // Duration label
        const durationLabel = document.createElement('div');
        durationLabel.className = 'task-duration';
        durationLabel.textContent = duration + ' min';
        durationLabel.style.left = (currentStart * pixelsPerMin + 10) + 'px';
        barContainer.appendChild(durationLabel);

        // Hold window extension (if any)
        if (holdWindow > 0) {
          const extension = document.createElement('div');
          extension.className = 'task-bar-extension';
          extension.style.left = ((currentStart + duration) * pixelsPerMin) + 'px';
          extension.style.width = (holdWindow * pixelsPerMin) + 'px';
          barContainer.appendChild(extension);

          // Hold window label
          const holdLabel = document.createElement('div');
          holdLabel.className = 'hold-window-label';

          if (holdWindow >= 1440) {
            const days = Math.floor(holdWindow / 1440);
            holdLabel.textContent = `can hold ${days}d`;
          } else if (holdWindow >= 60) {
            const hours = Math.floor(holdWindow / 60);
            holdLabel.textContent = `can hold ${hours}h`;
          } else {
            holdLabel.textContent = `can hold ${holdWindow}m`;
          }

          holdLabel.style.left = ((currentStart + duration) * pixelsPerMin + 10) + 'px';
          barContainer.appendChild(holdLabel);
        }

        track.appendChild(barContainer);
        tracks.appendChild(track);

        currentStart += duration;
      });

      // Update info
      document.getElementById('timelineInfo').textContent =
        `${chainData.tasks.length} tasks • ${totalDuration} min cook time • Max hold: ${formatDuration(maxHoldWindow)}`;

      // Update stats
      const statsHtml = chainData.tasks.map((task, idx) => {
        const hold = task.hold_window_minutes || 0;
        const flex = task.temporal_flexibility || 'unknown';
        return `<strong>${idx + 1}. ${task.canonical_verb}</strong>: ${task.planned_min || 0} min → hold ${formatDuration(hold)} (${flex})`;
      }).join('<br>');

      document.getElementById('stats').innerHTML = `
        <strong>Chain: ${chainData.name}</strong><br><br>
        ${statsHtml}
      `;
    };

    function formatDuration(minutes) {
      if (minutes >= 1440) {
        return `${(minutes / 1440).toFixed(1)} days`;
      } else if (minutes >= 60) {
        return `${(minutes / 60).toFixed(1)} hours`;
      } else {
        return `${minutes} min`;
      }
    }

    // Auto-load on page load
    // window.addEventListener('load', () => {
    //   window.loadMacAndCheese();
    // });
  </script>
</body>
</html>
